# Browser Use Agent - Complete Setup Guide

A full-stack web application for browser automation using the browser-use library with real-time monitoring and control.

## ðŸ—ï¸ Project Structure

```
project-root/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â”œâ”€â”€ .env.example
â”‚   â”œâ”€â”€ start_backend.py
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ core/
â”‚       â”‚   â””â”€â”€ config.py
â”‚       â”œâ”€â”€ db/
â”‚       â”‚   â”œâ”€â”€ database.py
â”‚       â”‚   â””â”€â”€ models.py
â”‚       â”œâ”€â”€ api/endpoints/
â”‚       â”‚   â”œâ”€â”€ health.py
â”‚       â”‚   â””â”€â”€ tasks.py
â”‚       â”œâ”€â”€ services/
â”‚       â”‚   â””â”€â”€ task_service.py
â”‚       â”œâ”€â”€ agent/
â”‚       â”‚   â”œâ”€â”€ agent_manager.py
â”‚       â”‚   â””â”€â”€ socket_manager.py
â”‚       â””â”€â”€ schemas/
â”‚           â””â”€â”€ schemas.py
â””â”€â”€ frontend/
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ pages/
    â”‚   â”œâ”€â”€ services/
    â”‚   â”‚   â”œâ”€â”€ apiService.ts
    â”‚   â”‚   â””â”€â”€ webSocketService.ts
    â”‚   â””â”€â”€ hooks/
    â”‚       â””â”€â”€ useTask.ts
    â””â”€â”€ package.json
```

## ðŸš€ Quick Start

### Prerequisites

- Python 3.8+
- Node.js 16+
- OpenAI API Key or Anthropic API Key

### 1. Backend Setup

```bash
# Clone/navigate to backend directory
cd backend

# Install Python dependencies
pip install -r requirements.txt

# Setup environment variables
cp .env.example .env
```

Edit `.env` file:
```env
# Database
DATABASE_URL=sqlite:///./browser_agent.db

# LLM API Keys (add at least one)
OPENAI_API_KEY=your_openai_api_key_here
ANTHROPIC_API_KEY=your_anthropic_api_key_here

# Browser Configuration
HEADLESS_BROWSER=false
BROWSER_TYPE=chromium

# CORS (for frontend)
BACKEND_CORS_ORIGINS=http://localhost:3000,http://localhost:5173
```

### 2. Install Browser Dependencies

```bash
# Install Playwright browsers
playwright install chromium

# Or install all browsers
playwright install
```

### 3. Start Backend

```bash
# Option 1: Using startup script
python start_backend.py

# Option 2: Direct uvicorn
uvicorn main:app --host 0.0.0.0 --port 8000 --reload
```

Backend will be available at: `http://localhost:8000`
API Documentation: `http://localhost:8000/docs`

### 4. Frontend Setup

```bash
# Navigate to frontend directory
cd frontend

# Install dependencies
npm install

# Add environment variables (create .env)
echo "VITE_API_BASE_URL=http://localhost:8000" > .env
echo "VITE_WS_BASE_URL=ws://localhost:8000" >> .env

# Start development server
npm run dev
```

Frontend will be available at: `http://localhost:5173` or `http://localhost:3000`

## ðŸ”§ Integration with Existing Frontend

If you have an existing React frontend, follow these steps:

### 1. Add Services

Copy these files to your `src/services/` directory:
- `apiService.ts` - HTTP API client
- `webSocketService.ts` - WebSocket client

### 2. Add Hooks

Copy `useTask.ts` to your `src/hooks/` directory.

### 3. Update Your Components

Replace your existing task management logic:

```typescript
// Old way (from your artifact)
const [tasks, setTasks] = useState(mockTasks);
const [taskSteps, setTaskSteps] = useState([]);

// New way (with real backend)
import { useTask, useTasks } from '../hooks/useTask';

// For task execution page
const { task, steps, isConnected, pauseTask, resumeTask, stopTask } = useTask(taskId);

// For dashboard/task list
const { tasks, loadTasks, deleteTask } = useTasks();
```

### 4. Update Task Creation

```typescript
// Old way
const handleSendMessage = async (messageText) => {
  // Mock implementation
};

// New way
const { createTask } = useTask();

const handleSendMessage = async (messageText) => {
  try {
    await createTask(messageText);
    // Navigate to task execution page
  } catch (error) {
    console.error('Failed to create task:', error);
  }
};
```

## ðŸŽ¯ Key Features

### Real-time Agent Monitoring
- **Live step updates** via WebSocket
- **Browser automation** with browser-use library
- **Pause/Resume/Stop** controls
- **Error handling** and recovery

### API Endpoints
- `POST /api/v1/tasks` - Create new task
- `GET /api/v1/tasks` - List all tasks
- `GET /api/v1/tasks/{id}` - Get task details
- `POST /api/v1/tasks/{id}/pause` - Pause task
- `POST /api/v1/tasks/{id}/resume` - Resume task
- `POST /api/v1/tasks/{id}/stop` - Stop task
- `DELETE /api/v1/tasks/{id}` - Delete task
- `WS /ws/{task_id}` - Real-time updates

### Browser-Use Integration
- **Multi-LLM support** (OpenAI, Anthropic)
- **Playwright browser** automation
- **Step-by-step monitoring** with detailed logging
- **Configurable browser** settings (headless/headed)

## ðŸ” How It Works

1. **User submits task** â†’ Frontend calls API to create task
2. **Backend starts agent** â†’ Initializes browser-use agent with LLM
3. **Agent executes** â†’ Performs browser automation step-by-step
4. **Real-time updates** â†’ WebSocket streams progress to frontend
5. **User controls** â†’ Can pause, resume, or stop execution
6. **Task completion** â†’ Results stored in database

## ðŸ› ï¸ Configuration Options

### Browser Settings
```python
# In agent_manager.py
browser_config = BrowserConfig(
    headless=False,  # Set to True for headless mode
    browser_type=BrowserType.CHROMIUM,  # CHROMIUM, FIREFOX, WEBKIT
    minimum_wait_page_load_time=2,
    wait_for_network_idle_time=3,
    maximum_wait_page_load_time=30,
)
```

### LLM Settings
```python
# OpenAI
llm = ChatOpenAI(
    model="gpt-4o",
    temperature=0.1,
    timeout=60
)

# Anthropic
llm = ChatAnthropic(
    model="claude-3-5-sonnet-20241022",
    temperature=0.1,
    timeout=60
)
```

## ðŸ› Troubleshooting

### Backend Issues

**Error: "No LLM API key provided"**
```bash
# Add API key to .env file
OPENAI_API_KEY=your_key_here
# or
ANTHROPIC_API_KEY=your_key_here
```

**Error: "Browser not found"**
```bash
# Install Playwright browsers
playwright install chromium
```

**Error: "Database connection failed"**
```bash
# Check DATABASE_URL in .env
DATABASE_URL=sqlite:///./browser_agent.db
```

### Frontend Issues

**Error: "Network Error"**
- Check if backend is running on `http://localhost:8000`
- Verify CORS settings in backend `.env`

**Error: "WebSocket connection failed"**
- Ensure WebSocket URL is correct: `ws://localhost:8000`
- Check browser developer tools for WebSocket errors

### Agent Issues

**Error: "Agent execution failed"**
- Check browser automation logs in backend console
- Verify the website is accessible
- Try with `headless=False` to see browser actions

## ðŸ“‹ Development Tips

### Testing the System

1. **Start backend** and check health endpoint:
   ```bash
   curl http://localhost:8000/api/v1/health
   ```

2. **Create a test task**:
   ```bash
   curl -X POST http://localhost:8000/api/v1/tasks \
     -H "Content-Type: application/json" \
     -d '{"prompt": "Navigate to google.com and search for browser automation"}'
   ```

3. **Monitor WebSocket** (using browser dev tools):
   ```javascript
   const ws = new WebSocket('ws://localhost:8000/ws/TASK_ID');
   ws.onmessage = (event) => console.log(JSON.parse(event.data));
   ```

### Production Deployment

For production, consider:
- Using PostgreSQL instead of SQLite
- Adding authentication/authorization
- Setting up proper logging and monitoring
- Using HTTPS/WSS for secure connections
- Containerizing with Docker

## ðŸ“ Example Usage

```typescript
// Create and monitor a task
const TaskExample = () => {
  const [taskId, setTaskId] = useState<string>();
  const { task, steps, isConnected, createTask, pauseTask } = useTask(taskId);

  const handleCreateTask = async () => {
    try {
      const newTask = await createTask("Search for AI news on Hacker News");
      setTaskId(newTask.id);
    } catch (error) {
      console.error('Failed to create task:', error);
    }
  };

  return (
    <div>
      <button onClick={handleCreateTask}>Create Task</button>
      {task && (
        <div>
          <h3>Task Status: {task.status}</h3>
          <div>Steps: {steps.length}</div>
          <button onClick={pauseTask}>Pause</button>
        </div>
      )}
    </div>
  );
};
```

This setup provides a complete, production-ready browser automation platform with real-time monitoring and control capabilities!